{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{267:function(s,e,l){\"use strict\";l.r(e);var a=l(38),n=Object(a.a)({},function(){var s=this,e=s.$createElement,l=s._self._c||e;return l(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":s.$parent.slotKey}},[l(\"h1\",{attrs:{id:\"子-shell\"}},[l(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#子-shell\",\"aria-hidden\":\"true\"}},[s._v(\"#\")]),s._v(\" 子 shell\")]),s._v(\" \"),l(\"blockquote\",[l(\"p\",[s._v(\"命令替换会创建一个子shell来运行对应的命令。 子shell (subshell) 是由运行该脚本的shell 所创建出来的一个独立的子shell(child shell) 。正因如此,由该子shell所执行命令是无法使用脚本中所创建的变量的。\\n在命令行提示符下使用路径./运行命令的话,也会创建出子shell;要是运行命令的时候不加入路径,就不会创建子shell。如果你使用的是内建的shell命令j,并不会涉及子shell。\\n在命令行提示符下运行脚本时一定要留心!\\nby:《Linux 命令行与 shell 脚本编程大全》 -p218\")])]),s._v(\" \"),l(\"h2\",{attrs:{id:\"cd-不生效\"}},[l(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#cd-不生效\",\"aria-hidden\":\"true\"}},[s._v(\"#\")]),s._v(\" cd 不生效\")]),s._v(\" \"),l(\"p\",[s._v(\"在学习的时候，经常要切换到固定的文件夹，于是写了个shell脚本用cd命令切换却发现目录切换不了。\")]),s._v(\" \"),l(\"div\",{staticClass:\"language-sh line-numbers-mode\"},[l(\"pre\",{pre:!0,attrs:{class:\"language-sh\"}},[l(\"code\",[l(\"span\",{pre:!0,attrs:{class:\"token shebang important\"}},[s._v(\"#! /bin/bash\")]),s._v(\"\\n\"),l(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"# c.sh\")]),s._v(\"\\n\\n\"),l(\"span\",{pre:!0,attrs:{class:\"token builtin class-name\"}},[s._v(\"cd\")]),s._v(\" ~\\n\"),l(\"span\",{pre:!0,attrs:{class:\"token builtin class-name\"}},[s._v(\"pwd\")]),s._v(\"\\n\")])]),s._v(\" \"),l(\"div\",{staticClass:\"line-numbers-wrapper\"},[l(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),l(\"br\"),l(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),l(\"br\"),l(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),l(\"br\"),l(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),l(\"br\"),l(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),l(\"br\")])]),l(\"p\",[s._v(\"解释：执行的时候是./c.sh来执行的，这样执行的话终端会产生一个子shell（类似于C语言调用函数），子shell去执行我的脚本，在子shell中已经切换了目录了，但是子shell一旦执行完，马上退出，子shell中的变量和操作全部都收回。回到终端根本就看不到这个过程的变化。\")]),s._v(\" \"),l(\"p\",[s._v(\"验证解释:\")]),s._v(\" \"),l(\"div\",{staticClass:\"language-sh line-numbers-mode\"},[l(\"pre\",{pre:!0,attrs:{class:\"language-sh\"}},[l(\"code\",[l(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"#！ /bin/bash\")]),s._v(\"\\n\"),l(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"# c.sh\")]),s._v(\"\\n\\n\"),l(\"span\",{pre:!0,attrs:{class:\"token builtin class-name\"}},[s._v(\"cd\")]),s._v(\" ~\\n\"),l(\"span\",{pre:!0,attrs:{class:\"token builtin class-name\"}},[s._v(\"pwd\")]),s._v(\"\\n\")])]),s._v(\" \"),l(\"div\",{staticClass:\"line-numbers-wrapper\"},[l(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),l(\"br\"),l(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),l(\"br\"),l(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),l(\"br\"),l(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),l(\"br\"),l(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),l(\"br\")])]),l(\"p\",[s._v(\"执行\"),l(\"code\",[s._v(\"./c.sh\")]),s._v(\",可以看到输出\"),l(\"code\",[s._v(\"/Users/xxx\")]),s._v(\",说明 cd 命令在子 shell 中其实是生效了的.\")]),s._v(\" \"),l(\"p\",[s._v(\"解决方法:直接在终端的shell执行脚本，没有生成子shell。\")]),s._v(\" \"),l(\"ol\",[l(\"li\",[l(\"code\",[s._v(\"source c.sh\")])]),s._v(\" \"),l(\"li\",[l(\"code\",[s._v(\". ./c.sh\")])])]),s._v(\" \"),l(\"p\",[s._v(\"注意上面. ./c.sh .和.中间有个空格！\")]),s._v(\" \"),l(\"div\",{staticClass:\"tip custom-block\"},[l(\"p\",[s._v(\"将shell脚本改为可执行文件:\"),l(\"code\",[s._v(\"chmod +x ./c.sh\")])])])])},[],!1,null,null,null);e.default=n.exports}}]);","extractedComments":[]}